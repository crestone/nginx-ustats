*** src/core/ngx_core.h	2011-02-08 10:39:27.039866002 +0500
--- ../nginx-0.8.53-dev/src/core/ngx_core.h	2011-03-16 17:10:04.325172002 +0500
***************
*** 90,93 ****
--- 90,129 ----
  void ngx_cpuinfo(void);
  
  
+ #if (NGX_HAVE_USTATS_MODULE)
+ /// Number of counters for each peer
+ #define USTATS_PEER_STATS_COUNT           8
+ 
+ /// Stat offset relative to the peer position within the shared memory
+ #define USTATS_REQ_STAT_INDEX             0
+ 
+ /// Holds HTTP 499 errors count
+ #define USTATS_HTTP499_STAT_INDEX         1
+ 
+ /// Holds HTTP 500 errors count
+ #define USTATS_HTTP500_STAT_INDEX         2
+ 
+ /// Holds HTTP 503 errors count
+ #define USTATS_HTTP503_STAT_INDEX         3
+ 
+ /// Holds TCP errors count
+ #define USTATS_TCP_ERR_STAT_INDEX         4
+ 
+ /// Holds read timeouts count
+ #define USTATS_READ_TIMEOUT_STAT_INDEX    5
+ 
+ /// Holds write timeouts count
+ #define USTATS_WRITE_TIMEOUT_STAT_INDEX   6
+ 
+ /// Holds last failed access time across all workers
+ #define USTATS_BLACKLISTED_STAT_INDEX     7
+ 
+ /// Shared memory for storing counters. Defined in ngx_http_ustats_module.c
+ extern ngx_shm_zone_t * stats_data;
+ /// Counter used to distribute shared memory among backends
+ extern ngx_uint_t ustats_shm_index;
+ 
+ #endif
+ 
+ 
  #endif /* _NGX_CORE_H_INCLUDED_ */
*** src/http/ngx_http_upstream.c	2011-02-08 10:39:27.019866002 +0500
--- ../nginx-0.8.53-dev/src/http/ngx_http_upstream.c	2011-03-16 17:00:55.835172001 +0500
***************
*** 1106,1111 ****
--- 1106,1120 ----
  
      c = u->peer.connection;
  
+ #if (NGX_HAVE_USTATS_MODULE)
+     if (stats_data)
+     {
+ 		ngx_http_upstream_rr_peer_data_t  *rrp = u->peer.data;
+ 		ngx_atomic_fetch_add((ngx_atomic_uint_t*)stats_data->data +
+ 			rrp->peers->peer[rrp->current].shm_start_ind + USTATS_REQ_STAT_INDEX, 1);
+     }
+ #endif
+ 
      c->data = r;
  
      c->write->handler = ngx_http_upstream_handler;
***************
*** 1416,1421 ****
--- 1425,1438 ----
                     "http upstream send request handler");
  
      if (c->write->timedout) {
+ #if (NGX_HAVE_USTATS_MODULE)
+ 		if (stats_data)
+ 		{
+ 			ngx_http_upstream_rr_peer_data_t  *rrp = u->peer.data;
+ 			ngx_atomic_fetch_add((ngx_atomic_uint_t*)stats_data->data +
+ 				rrp->peers->peer[rrp->current].shm_start_ind + USTATS_WRITE_TIMEOUT_STAT_INDEX, 1);
+ 		}
+ #endif
          ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_TIMEOUT);
          return;
      }
***************
*** 1456,1461 ****
--- 1473,1486 ----
      c->log->action = "reading response header from upstream";
  
      if (c->read->timedout) {
+ #if (NGX_HAVE_USTATS_MODULE)
+ 		if (stats_data)
+ 		{
+ 			ngx_http_upstream_rr_peer_data_t  *rrp = u->peer.data;
+ 			ngx_atomic_fetch_add((ngx_atomic_uint_t*)stats_data->data +
+ 				rrp->peers->peer[rrp->current].shm_start_ind + USTATS_READ_TIMEOUT_STAT_INDEX, 1);
+ 		}
+ #endif
          ngx_http_upstream_next(r, u, NGX_HTTP_UPSTREAM_FT_TIMEOUT);
          return;
      }
***************
*** 1636,1641 ****
--- 1661,1687 ----
  
      status = u->headers_in.status_n;
  
+ #if (NGX_HAVE_USTATS_MODULE)
+     if (stats_data)
+     {
+ 		ngx_http_upstream_rr_peer_data_t  *rrp = u->peer.data;
+ 		switch (status)
+ 		{
+ 			case 500:
+ 				ngx_atomic_fetch_add((ngx_atomic_uint_t*)stats_data->data +
+ 					rrp->peers->peer[rrp->current].shm_start_ind + USTATS_HTTP500_STAT_INDEX, 1);
+ 				break;
+ 
+ 			case 503:
+ 				ngx_atomic_fetch_add((ngx_atomic_uint_t*)stats_data->data +
+ 					rrp->peers->peer[rrp->current].shm_start_ind + USTATS_HTTP503_STAT_INDEX, 1);
+ 
+ 			default:
+ 				break;
+ 		}
+     }
+ #endif
+ 
      for (un = ngx_http_upstream_next_errors; un->status; un++) {
  
          if (status != un->status) {
***************
*** 2780,2785 ****
--- 2826,2841 ----
  {
      ngx_uint_t  status, state;
  
+ #if (NGX_HAVE_USTATS_MODULE)
+     if (stats_data)
+     {
+ 		ngx_http_upstream_rr_peer_data_t *rrp = u->peer.data;
+ 		if (rrp->peers->peer[rrp->current].fails + 1 >= rrp->peers->peer[rrp->current].max_fails
+ 			|| rrp->peers->peer[rrp->current].max_fails == 1)
+ 			((time_t*)stats_data->data)[rrp->peers->peer[rrp->current].shm_start_ind + USTATS_BLACKLISTED_STAT_INDEX] = ngx_time();
+     }
+ #endif
+ 
      ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                     "http next upstream, %xi", ft_type);
  
***************
*** 3020,3025 ****
--- 3076,3093 ----
          rc = ngx_http_send_special(r, NGX_HTTP_LAST);
      }
  
+ #if (NGX_HAVE_USTATS_MODULE)
+     if (stats_data)
+     {
+ 		ngx_http_upstream_rr_peer_data_t *rrp = u->peer.data;
+ 		if (rc == NGX_HTTP_CLIENT_CLOSED_REQUEST)
+ 		{
+ 			ngx_atomic_fetch_add((ngx_atomic_uint_t*)stats_data->data +
+ 					rrp->peers->peer[rrp->current].shm_start_ind + USTATS_HTTP499_STAT_INDEX, 1);
+ 		}
+     }
+ #endif
+ 
      ngx_http_finalize_request(r, rc);
  }
  
***************
*** 4074,4079 ****
--- 4142,4153 ----
      u.url = value[1];
      u.default_port = 80;
  
+ #if (NGX_HAVE_USTATS_MODULE)
+     us->name.data = ngx_pnalloc(cf->pool, (u.url.len + 1/* with '\0' ?*/) * sizeof(u_char));
+     us->name.len = u.url.len;
+     (void)ngx_cpymem(us->name.data, u.url.data, u.url.len + 1);
+ #endif
+ 
      if (ngx_parse_url(cf->pool, &u) != NGX_OK) {
          if (u.err) {
              ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
*** src/http/ngx_http_upstream.h	2011-02-08 10:39:27.019866002 +0500
--- ../nginx-0.8.53-dev/src/http/ngx_http_upstream.h	2011-02-08 10:29:41.519866001 +0500
***************
*** 89,94 ****
--- 89,98 ----
  
      unsigned                         down:1;
      unsigned                         backup:1;
+ 
+ #if (NGX_HAVE_USTATS_MODULE)
+     ngx_str_t                        name; // original name, unresolved
+ #endif
  } ngx_http_upstream_server_t;
  
  
*** src/http/ngx_http_upstream_round_robin.c	2011-02-08 10:39:27.019866002 +0500
--- ../nginx-0.8.53-dev/src/http/ngx_http_upstream_round_robin.c	2011-02-28 13:01:39.930333001 +0500
***************
*** 9,14 ****
--- 9,24 ----
  #include <ngx_http.h>
  
  
+ #if (NGX_HAVE_USTATS_MODULE)
+ ngx_uint_t ustats_shm_index = 0;
+ #endif
+ 
+ 
+ #if (NGX_HAVE_USTATS_MODULE)
+ static ngx_int_t
+ ngx_http_upstream_cmp_implicit_servers(const void * one, const void * two);
+ #endif
+ 
  static ngx_int_t ngx_http_upstream_cmp_servers(const void *one,
      const void *two);
  static ngx_uint_t
***************
*** 65,70 ****
--- 75,85 ----
                  peers->peer[n].down = server[i].down;
                  peers->peer[n].weight = server[i].down ? 0 : server[i].weight;
                  peers->peer[n].current_weight = peers->peer[n].weight;
+ #if (NGX_HAVE_USTATS_MODULE)
+                 peers->peer[n].server = server + i;
+                 peers->peer[n].shm_start_ind = ustats_shm_index;
+                 ustats_shm_index += USTATS_PEER_STATS_COUNT;
+ #endif
                  n++;
              }
          }
***************
*** 118,123 ****
--- 133,143 ----
                  backup->peer[n].max_fails = server[i].max_fails;
                  backup->peer[n].fail_timeout = server[i].fail_timeout;
                  backup->peer[n].down = server[i].down;
+ #if (NGX_HAVE_USTATS_MODULE)
+                 peers->peer[n].server = server + i;
+                 peers->peer[n].shm_start_ind = ustats_shm_index;
+                 ustats_shm_index += USTATS_PEER_STATS_COUNT;
+ #endif
                  n++;
              }
          }
***************
*** 178,183 ****
--- 198,222 ----
          peers->peer[i].fail_timeout = 10;
      }
  
+ #if (NGX_HAVE_USTATS_MODULE)
+ 	/**
+ 	 * Implicit peers order may change between two
+ 	 * configuration rescans. To maintain pointer
+ 	 * correctness, we always sort peers here
+ 	 */
+ 
+     ngx_sort(&peers->peer[0], (size_t)u.naddrs,
+ 			 sizeof(ngx_http_upstream_rr_peer_t),
+ 			 ngx_http_upstream_cmp_implicit_servers);
+ 
+     for (i = 0; i < u.naddrs; i++)
+     {
+         peers->peer[i].server = NULL;
+         peers->peer[i].shm_start_ind = ustats_shm_index;
+         ustats_shm_index += USTATS_PEER_STATS_COUNT;
+     }
+ #endif
+ 
      us->peer.data = peers;
  
      /* implicitly defined upstream has no backup servers */
***************
*** 198,203 ****
--- 237,256 ----
  }
  
  
+ #if (NGX_HAVE_USTATS_MODULE)
+ static ngx_int_t
+ ngx_http_upstream_cmp_implicit_servers(const void * one, const void * two)
+ {
+ 	ngx_http_upstream_rr_peer_t *first, *second;
+ 
+ 	first = (ngx_http_upstream_rr_peer_t*)one;
+ 	second = (ngx_http_upstream_rr_peer_t*)two;
+ 
+ 	return ngx_strcmp(first->name.data, second->name.data);
+ }
+ #endif
+ 
+ 
  ngx_int_t
  ngx_http_upstream_init_round_robin_peer(ngx_http_request_t *r,
      ngx_http_upstream_srv_conf_t *us)
*** src/http/ngx_http_upstream_round_robin.h	2011-02-08 10:39:27.019866002 +0500
--- ../nginx-0.8.53-dev/src/http/ngx_http_upstream_round_robin.h	2011-02-08 10:28:55.739866001 +0500
***************
*** 32,37 ****
--- 32,43 ----
  #if (NGX_HTTP_SSL)
      ngx_ssl_session_t              *ssl_session;   /* local to a process */
  #endif
+ 
+ #if (NGX_HAVE_USTATS_MODULE)
+     /* points to the server whose configuration was used for this peer */
+     ngx_http_upstream_server_t      *server;
+     ngx_uint_t                      shm_start_ind;
+ #endif
  } ngx_http_upstream_rr_peer_t;
  
  
*** src/os/unix/ngx_process_cycle.c	2011-02-08 10:39:27.029866002 +0500
--- ../nginx-0.8.53-dev/src/os/unix/ngx_process_cycle.c	2011-03-16 20:16:36.085172002 +0500
***************
*** 10,15 ****
--- 10,24 ----
  #include <ngx_channel.h>
  
  
+ #if (NGX_HAVE_USTATS_MODULE)
+ /**
+  * Shared memory last write peer index.
+  * Reset when sighup is received by nginx
+  */
+ extern ngx_uint_t ustats_shm_index;
+ #endif
+ 
+ 
  static void ngx_start_worker_processes(ngx_cycle_t *cycle, ngx_int_t n,
      ngx_int_t type);
  static void ngx_start_cache_manager_processes(ngx_cycle_t *cycle,
***************
*** 226,231 ****
--- 235,245 ----
          if (ngx_reconfigure) {
              ngx_reconfigure = 0;
  
+ #if (NGX_HAVE_USTATS_MODULE)
+             stats_data = NULL;
+             ustats_shm_index = 0;
+ #endif
+ 
              if (ngx_new_binary) {
                  ngx_start_worker_processes(cycle, ccf->worker_processes,
                                             NGX_PROCESS_RESPAWN);
***************
*** 318,323 ****
--- 332,341 ----
  
          if (ngx_reconfigure) {
              ngx_reconfigure = 0;
+ #if (NGX_HAVE_USTATS_MODULE)
+             stats_data = NULL;
+             ustats_shm_index = 0;
+ #endif
              ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0, "reconfiguring");
  
              cycle = ngx_init_cycle(cycle);
